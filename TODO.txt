1/04/19
AmmoTile e WeaponCard sono sia collectable che drawable perchè nel momento in cui le metto nel tabellone le sto pescando. 
Quelli che erano nel placeable li abbiamo divisi in:

1.Quelli che vanno della playerboard (DamageToken, SkullToken, FirstplayerToken e AmmoCube)
 2.PointCard (è CardInterface)
 3.Character. 
Playerhand contiene WeaponCard, PowerupCard, PointCard.
Bisogna realizzare anche i mazzi [MAZZO, MAZZOPOWERUP, MAZZOWEAPON).




2/04/19
Bisogna aggiungere le sottoclassi di character. 

DUBBI:	
1.	Pacchetto da sparare: BUONA IDEA.
	
2.	Se è utile fare le’iteminterface: Evitare di creare interfacce o 
	classi vuote basta mettere flag booleani. 	
3.	Json per le armi oppure strategy pattern: json simple library, BUONA IDEA. 	
4.	I punti bisogna modellarli? Devono essere poi associati alla risorsa 
	grafica giusta. Possiamo però farlo vedere accanto alla plancia del giocatore, non 
	serve avere la classe del punto 

5. 	Ma per gli Ammocubes è meglio una sola classe con un attributo per il colore 	
	oppure una interfaccia da cui ereditano le 3 classi dei cubi dei vari colori? 
	Perché comunque la powerupcard è anche un ammocube: FARE ATTRIBUTO, NON SERVE FARE 
	INTERFACCIA

7.	Come si tiene traccia della posizione? Si fa una mappa come matrice? Si fa una 
	matrice di oggetti, non di int. Getvisibleplayer() da ogni cella. Per i quadratini 
	NULL a quel punto possiamo scrivere che è una cella vuota, cioè proprio l'oggetto 
	cella vuota. 

Per il menu iniziale va bene la macchina a stati.
Per la prossima volta bisogna capire come fare il controllerò dal punto di vista della gestione delle azione, lo scorrere dei turni.
lo stato = modello
transizione = controller
implemento a livello di model ciò che è chiaro (mappa e cose semplici) e poi comincio a pensare gestione delle azioni, come vengono passati i parametri ecc.

Cambiare stato in base ai danni [mosse adrenaliniche]


4/04/19
Per UML:
Nell'implementazione delle armi mancano i diversi comportamenti delle singole armi. Quindi dobbiamo suddividerli in base a ciò che fanno [come possono sparare].
Mancano da modellare gli stati.

Per martedi dobbiamo scrivere anche il codice del Model. Oltre a fare i test e la doc.
Quindi dobbiamo identificare tutti i metodi.
DOMANI: Io e tommy [se teo non può] cerchiamo di identificare tutti i metodi delle classi.
SABATO: Cominciamo a scrivere codice delle classi perchè altrimenti non ce la facciamo.
DOMENICA: Test junit e doc
LUNEDI: tutto quello che ci manca



5/04/19
DA RICORDARE:
Abbiamo fatto un pattern state anche per le mosse adrenaliniche. Dato che nella PlayerBoard dobbiamo comunque salvare anche il numero di danni e gli autori degli stessi, possiamo farlo tramite per esempio una lista dei damagetoken. Quindi il player chiamerà il metodo getremaininghp nella board, che le conta e poi in base al risultato capisce in quale stato adrenalinico è. In base a ciò può eseguire altro codice per le mosse.

In Item display() serve a...?

Abbiamo tolto DOOR perchè tanto basta verificare che ci siano due celle adiacenti di colore diverso.

Abbiamo fatto derivare Ownable da ItemInterface perchè in questo modo abbiamo Ammotile [che può restituire sia ammocubes che powerupcards] che può avere un'istanza di entrambe.

Abbiamo pensato che possa servire il mazzo di cose scartate. Quindi abbiamo aggiunto il metodo discard nelle carte. Diciamo che il discard nelle powerup si aggiunge al mazzo delle carte scartate, mentre il discard nelle armi si fa quando ne si hanno 3 in mano e se ne vuole prendere un'altra.
**AGGIORNAMENTO** Abbiamo implementato il mazzo di carte scartate mettendo due liste dentro a powerupdesk: una lista attiva e una lista di scarto. Quando la lista attiva diventa vuota, si shuffla la lista di scarto.